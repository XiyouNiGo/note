# google-styleguide

## 1. 头文件

+ 所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。
+ .inc文件：对于template，为了使声明、定义分隔开，定义写在自己文件内部，即.inc文件，然后在.h文件的末尾包含进来。

+ 所有头文件都应该使用 `#define` 来防止头文件被多重包含, 命名格式当是: `<PROJECT>_<PATH>_<FILE>_H_` 。
+ 尽可能地避免使用前置声明。使用 `#include` 包含需要的头文件即可。
+ 只有当函数只有 10 行甚至更少时才将其定义为内联函数。
+ 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联。
+ ` #include ` 的路径及顺序：
  + 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h。
  + 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录。
  + 按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。
  + 所依赖的符号 (symbols) 被哪些头文件所定义，就应该包含（include）哪些头文件，哪怕已经被其他包含。
  + 平台特定（system-specific）代码需要条件编译（conditional includes），可以放到其它 includes 之后。

## 2. 作用域

+ 内联命名空间会自动把内部的标识符放到外层作用域。
+ 在 `std` 命名空间声明实体是未定义的行为, 会导致如不可移植。
+ 不应该使用 *using 指示* 引入整个命名空间的标识符号。
+ 命名空间都是具有external 连接属性的,只是匿名的命名空间产生的__UNIQUE_NAME__在别的文件中无法得到,这个唯一的名字是不可见的。
+ C++ 新的标准中提倡使用匿名命名空间,而不推荐使用static,因为static用在不同的地方,涵义不同,容易造成混淆.另外,static不能修饰class。
+ 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。
+ 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。
+ 静态和全局变量
  + 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。
  + `constexpr` 变量除外，毕竟它们又不涉及动态初始化或析构。
  + 除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 `getenv()` 或 `getpid()` ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。
  + 同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。
  + 全局和静态变量在程序中断时会被析构，顺序未定义。改善以上析构问题的办法之一是用 `quick_exit()` （不会执行任何析构）来代替 `exit()` 并中断程序。

## 3. 类

+ 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化。
+ 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 `explicit` 关键字。
+ 不能以一个参数进行调用的构造函数不应当加上 `explicit`。接受一个 `std::initializer_list` 作为参数的构造函数也应当省略 `explicit`, 以便支持拷贝初始化。
+ 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用。
+ 仅当只有数据成员时使用 `struct`, 其它一概使用 `class`。
+ `struct` 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能。 并且存取功能是通过直接访问位域, 而非函数调用。 除了构造函数, 析构函数, `Initialize()`, `Reset()`, `Validate()` 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数。
+ 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 `public` 继承。
+ 所有继承必须是 `public` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式。
+ 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 `Interface` 为后缀的纯接口类。
+ 接口是指满足特定条件的类, 这些类以 `Interface` 为后缀 (不强制)。
+ 只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算。
+ 类定义一般应以 `public:` 开始, 后跟 `protected:`, 最后是 `private:`. 省略空部分。

## 7. 命名约定

+ 函数命名, 变量命名, 文件命名要有描述性; 少用缩写。
+ 文件名要全部小写, 可以包含下划线 (`_`) 或连字符 (`-`)。
+ C++ 文件要以 `.cc` 结尾, 头文件以 `.h` 结尾. 专门插入文本的文件则以 `.inc` 结尾。
+ 类型名称的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`。
+ 所有类型命名 —— 类, 结构体, 类型定义 (`typedef`), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线。
+ 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`。
+ 声明为 `constexpr` 或 `const` 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合。
+ 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配。
+ 一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 `StartRpc()` 而非 `StartRPC()`)。
+ 命名空间以小写字母命名。对于 `internal` 命名空间, 要当心加入到同一 `internal` 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突)。 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 `frobber.h`, 使用 `websearch::index::frobber_internal`)。
+ 枚举的命名应当和常量或宏一致: `kEnumName` 或是 `ENUM_NAME`。单独的枚举值应该优先采用常量的命名方式。
+ 如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略。

## 8. 注释

+ 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。
+ `TODO` 注释要使用全大写的字符串 `TODO`, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 `TODO` 相关的 issue。
+ 通过弃用注释（`DEPRECATED` comments）以标记某接口点已弃用。

## 9. 格式

+ 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前。
+ 缺省缩进为 2 个空格，换行后的参数保持 4 个空格的缩进。
+ 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 `else` 子句时使用。
+ 如果 `default` 应该永远执行不到, 简单的加条 `assert`。
+ 空循环体应使用 `{}` 或 `continue`, 而不是一个简单的分号。
+ 预处理指令不要缩进, 从行首开始。
+ 访问控制块的声明依次序是 `public:`, `protected:`, `private:`, 每个都缩进 1 个空格。
+ 构造函数初始化列表放在同一行或按四格缩进并排多行。
+ 命名空间内容不缩进。
