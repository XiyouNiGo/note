# 你好，C++的并发世界

## 计算机系统中的并发

+ 进行上下文的切换时,操作系统必须为当前运行的任务保存CPU状态和指令指针,并计算出要切换到哪个任务,并为即将切换到的任务重新加载处理器状态。然后CPU可能要将新任务的指令和数据的内存载入到缓存中,这会阻止CPU执行任何指令,从而造成的多的延迟。

## 多进程并发

+ 操作系统在进程间提供附加的保护操作和更高级别的通信机制意味着可以更容易编写安全的并发代码。
+ 使用多进程实现并发还有一个额外的优势———可以使用远程连接(可能需要联网)的方式,在不同机器上运行独立的进程。虽然,这增加了通信成本,但在设计精良的系统上,这可能是一个提高并可用行和性能的低成本方式。 
+ 多个单线程/进程间的通信(包含启动)要比单一进程中的多线程间的通信(包括启动)的开销大。

## 为什么使用并发

+ 为了分离关注点。
+ 为了性能。将一个单个任务分成几部分,且各自并行运行,从而降低总运行时间。这就是任务并行(task parallelism)。

## 开始入门

+ 新的线程启动之后,初始线程继续执行。如果它不等待新线程结束,它就将自顾自地继续运行main()的结束,从而结束程序——有可能发生在新线程运行之前。

# 线程管理

## 线程管理的基础

+ 使用C++线程库启动线程,可以归结为构造std::thread对象。

+ std::thread可以用可调用类型构造,将带有函数调用符类型的实例传入std::thread类中,替换默认的构造函数。 

+ 提供的函数对象会复制到新线程的存储空间当中,函数对象的执行和调用都在线程的内存空间中进行。函数对象的副本应与原始函数对象保持一致,否则得到的结果会与我们的期望不同。 

+ 如果你传递了一个临时变量,而不是一个命名的变量;C++编译器会将其解析为函数声明,而不是类型对象的定义。

  使用在前面命名函数对象的方式,或使用多组括号,或使用新统一的初始化语法,可以避免这个问题。

  使用lambda表达式也能避免这个问题。

+ std::thread的析构函数会调用std::terminate()。

+ 如果不等待线程,就必须保证线程结束之前,可访问的数据得有效性。

  处理方法：将数据复制到线程中,而非复制到共享数据中，对于对象中包含的指针和引用还需谨慎。

+ 只能对一个线程使用一次join()，一旦使用过join()， std::thread 对象就不能再次汇入了。当对其使用joinable()时，将返回false。
+ 避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。
+ 调用 std::thread 成员函数detach()来分离一个线程。之后，相应的 std::thread 对象就与实际执行的线程无关了，并且这个线程也无法汇入。
+ 当 std::thread 对象使用t.joinable()返回的是true，就可以使用t.detach()。
+ 不仅可以向 std::thread 构造函数传递函数名，还可以传递函数所需的参数(实参)。当然，也有其他方法可以完成这项功能，比如：使用带有数据的成员函数，代替需要传参的普通函数。

## 传递参数

+ 这些参数会拷贝至新线程的内存空间中(同临时变量一样)。即使函数中的参数是引用的形式，拷贝操作也会执行。
+ 无法保证隐式转换的操作和 std::thread 构造函数的拷贝操作的顺序，解决方案就是在传递到 std::thread 构造函数之前，就将字面值转化为 std::string。
+ **使用std::ref传递std::thread回调函数中的引用**。
+ 也可以传递一个成员函数指针作为线程函数，并提供一个合适的对象指针作为第一个参数。
+ 使用移动操作可以将对象转换成函数可接受的实参类型，或满足函数返回值类型要求。
+ 线程的所有权可以在多个 std::thread 实例中转移，这依赖于 std::thread 实例的可移动且不可复制性。
+ 赋值给一个已经有关联线程的std::thread，系统直接调用 std::terminate() 终止程序继续运行。
+ 不能通过赋新值给 std::thread 对象的方式来"丢弃"一个线程。
+ 如果这个容器是移动敏感的(比如，标准中的 std::vector<> )，那么移动操作同样适用于这些容器。
+ 函数模板std :: mem_fn生成指向成员的指针的包装对象，该对象可以存储，复制和调用指向成员的指针。 调用std :: mem_fn时，可以使用对象的引用和指针（包括智能指针）。

# 共享数据

+ C++标准库为互斥量提供了RAII模板类 std::lock_guard ，在构造时就能提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。

+ C++17中添加了一个新特性，称为模板类参数推导，类似 std::lock_guard 这样简单的模板类型，其模板参数列表可以省略。

+ 一个指针或引用，也会让这种保护形同虚设。

+ 对于有返回值的pop()函数来说，只有“异常安全”方面的担忧（当拷贝构造函数在栈中抛出一个异常）。

  解决方案：

  + 将变量的引用作为参数。有些类型可能不支持赋值操作。
  + **无异常抛出的拷贝构造函数或移动构造函数**（意义就在此）。有抛出异常的拷贝构造函数往往更多。
  + 返回指向弹出值的指针（shared_ptr）。对于简单数据类型(比如:int)，内存管理的开销要远大于直接返回值。

+ 避免死锁的一般建议，就是让两个互斥量以相同的顺序上锁。

+ std::lock ——可以一次性锁住多个互斥量，并且没有副作用(死锁风险)。

+ std::scoped_lock<> 是一种新的RAII模板类型，与 std::lock_guard<> 的功能相同，这个新类型能接受不定数量的互斥量类型作为模板参数，以及相应的互斥量(数量和类型)作为构造参数。互斥量支持构造时上锁，与 std::lock 的用法相同，解锁在析构中进行。

+ 避免死锁的进阶指导：

  + 避免嵌套锁。
  + 避免在持有锁时调用外部代码。
  + 使用固定顺序获取锁。
  + 使用层次锁结构。当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定。因此锁的顺序只能先锁层级高的锁再锁层级低的锁。
  
+ std::unique_lock 实例不会总与互斥量的数据类型相关，使用起来要比 std:lock_guard 更加灵活。 std::unique_lock 会占用比较多的空间，并且比 std::lock_guard 稍慢一些（需要维护锁的状态）。当实例中没有互斥量时，析构函数就不能去调用unlock()，这个标志可以通过owns_lock()成员变量进行查询。 std::unique_lock 是可移动，但不可赋值的类型。

+ 一般情况下，尽可能将持有锁的时间缩减到最小。

+ 双重检查锁模式：解决Singleton实际上只有第一次实例创建的时候才需要加锁。new operator和reset可能发生**指令重排**，不安全。C++标准库提供std::once_flag 和 std::call_once 来处理这种情况。

+ 用 `std::unique_lock` 与 `std::lock_guard` 管理排他性锁定。

  用 `std::shared_lock` 管理共享锁定。

# 同步操作

+ std::condition_variable_any 更加通用，不过在性能和系统资源的使用方面会有更多的开销，所以通常会将 std::condition_variable 作为首选类型。
+ std::future提供访问异步操作结果的机制。std::future 只能与指定事件相关联，而 std::shared_future 就能关联多个事件。future对象本身并不提供同步访问。
+ 当不着急让任务结果时，可以使用 std::async 启动一个异步任务。std::async 会返回一个 std::future 对象。get()等价与先调用wait()再调用get()。 std::launch::defered 表明函数调用延迟到wait()或get()函数调用时才执行，std::launch::async 表明函数必须在其所在的独立线程上执行。当函数调用延迟，可能不会再运行。
+ std::packaged_task<> 会将future与函数或可调用对象进行绑定。当 std::packaged_task 作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在 std::future 中。
+  std::promise/std::future 对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。
+ 任何情况下，当future的状态还不是“就绪”时，调用 std::promise 或 std::packaged_task 的析构函数，将会存储一个与 std::future_errc::broken_promise 错误状态相关的 std::future_error 异常。
+ 当调用抛出一个异常时，这个异常就会存储到future中，之后调用get()会抛出已存储的异常。
+  std::current_exception() 来检索抛出的异常，可用 std::copy_exception() 作为替代方案， std::copy_exception() 会直接存储新的异常而不抛出。
+ 因为 std::future 是只移动的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 std::shared_future 实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。
+ 为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。当每个线程都通过自己拥有的 std::shared_future 对象获取结果，那么多个线程访问共享同步结果就是安全的。
+ 函数化编程(functional programming)是一种编程方式，函数结果只依赖于传入函数的参数。使用相同的参数调用函数，不管多少次都会获得相同的结果，主要思想是把运算过程尽量写成一系列嵌套的函数调用。函数式编程不需要考虑"死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。

