# 你好，C++的并发世界

## 计算机系统中的并发

+ 进行上下文的切换时,操作系统必须为当前运行的任务保存CPU状态和指令指针,并计算出要切换到哪个任务,并为即将切换到的任务重新加载处理器状态。然后CPU可能要将新任务的指令和数据的内存载入到缓存中,这会阻止CPU执行任何指令,从而造成的多的延迟。

## 多进程并发

+ 操作系统在进程间提供附加的保护操作和更高级别的通信机制意味着可以更容易编写安全的并发代码。
+ 使用多进程实现并发还有一个额外的优势———可以使用远程连接(可能需要联网)的方式,在不同机器上运行独立的进程。虽然,这增加了通信成本,但在设计精良的系统上,这可能是一个提高并可用行和性能的低成本方式。 
+ 多个单线程/进程间的通信(包含启动)要比单一进程中的多线程间的通信(包括启动)的开销大。

## 为什么使用并发

+ 为了分离关注点。
+ 为了性能。将一个单个任务分成几部分,且各自并行运行,从而降低总运行时间。这就是任务并行(task parallelism)。

## 开始入门

+ 新的线程启动之后,初始线程继续执行。如果它不等待新线程结束,它就将自顾自地继续运行main()的结束,从而结束程序——有可能发生在新线程运行之前。

# 线程管理

## 线程管理的基础

+ 使用C++线程库启动线程,可以归结为构造std::thread对象。

+ std::thread可以用可调用类型构造,将带有函数调用符类型的实例传入std::thread类中,替换默认的构造函数。 

+ 提供的函数对象会复制到新线程的存储空间当中,函数对象的执行和调用都在线程的内存空间中进行。函数对象的副本应与原始函数对象保持一致,否则得到的结果会与我们的期望不同。 

+ 如果你传递了一个临时变量,而不是一个命名的变量;C++编译器会将其解析为函数声明,而不是类型对象的定义。

  使用在前面命名函数对象的方式,或使用多组括号,或使用新统一的初始化语法,可以避免这个问题。

  使用lambda表达式也能避免这个问题。

+ std::thread的析构函数会调用std::terminate()。

+ 如果不等待线程,就必须保证线程结束之前,可访问的数据得有效性。

  处理方法：将数据复制到线程中,而非复制到共享数据中，对于对象中包含的指针和引用还需谨慎。

+ 只能对一个线程使用一次join()，一旦使用过join()， std::thread 对象就不能再次汇入了。当对其使用joinable()时，将返回false。
+ 避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。
+ 调用 std::thread 成员函数detach()来分离一个线程。之后，相应的 std::thread 对象就与实际执行的线程无关了，并且这个线程也无法汇入。
+ 当 std::thread 对象使用t.joinable()返回的是true，就可以使用t.detach()。
+ 不仅可以向 std::thread 构造函数传递函数名，还可以传递函数所需的参数(实参)。当然，也有其他方法可以完成这项功能，比如：使用带有数据的成员函数，代替需要传参的普通函数。

## 传递参数

+ 这些参数会拷贝至新线程的内存空间中(同临时变量一样)。即使函数中的参数是引用的形式，拷贝操作也会执行。
+ 无法保证隐式转换的操作和 std::thread 构造函数的拷贝操作的顺序，解决方案就是在传递到 std::thread 构造函数之前，就将字面值转化为 std::string。
+ **使用std::ref传递std::thread回调函数中的引用**。
+ 也可以传递一个成员函数指针作为线程函数，并提供一个合适的对象指针作为第一个参数。
+ 使用移动操作可以将对象转换成函数可接受的实参类型，或满足函数返回值类型要求。
+ 线程的所有权可以在多个 std::thread 实例中转移，这依赖于 std::thread 实例的可移动且不可复制性。
+ 赋值给一个已经有关联线程的std::thread，系统直接调用 std::terminate() 终止程序继续运行。
+ 不能通过赋新值给 std::thread 对象的方式来"丢弃"一个线程。
+ 