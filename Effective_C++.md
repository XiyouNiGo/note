# 视C++为一个语言联邦

+ C、Object-Oriented C++、Template C++、STL。
+ 从某个次语言切换到另一个，可能导致高效编程守则改变。

# 尽量以const,enum,inline替换#define

+ 宁可以编译器替换预处理器。

+ 原因：
  + 宏定义的记号也许从未被编译器看到，编译出错时将因为追踪它而浪费时间。
  + 盲目替换可能导致目标码更大。
+ 常量定义式通常被放在头文件内（以便被不同的源码含入）。
+ string通常比其前辈char*-based更合时宜。
+ #define不能提供任何封装性。
+ 编译器不允许“static整数型class常量”完成“in class初值设定”，可改用“enum hack”补偿做法。
+ 如果不想别人获得一个pointer或reference指向某个整数常量，可以使用enum。
+ 用template inline函数代替宏函数（宏函数需要给每个变量加小括号，且变量带++运算符，可能++多次）。
+ 对于单纯常量，最好以const对象或enum替换#define。
+ 对于形似函数的宏，最好改用inline函数替换#define。

# 尽可能使用const

+ 如果希望STL模拟一个const T*指针，应该使用const_iterator而不是T* *const。
+ 令函数返回一个常量值，往往可以降低因客户错误而造成的意外（例如==写成=）。
+ 令non-const成员函数调用const成员函数是一个避免代码重复的安全做法（需要两次转型防止递归）。

# 确定对象被使用前已被初始化

+ 使用初始化列表效率更高（避免先调用default构造函数再调用拷贝赋值函数）。
+ 总是在初始化列表列出所有成员变量（不需要初始值的变量指定无物作为初始化实参即可，即直接加括号）。

+ class的成员变量总是以其声明次序被初始化，当在成员初值列中条列各个成员时，最好总是以其声明次序为次序。

+ C++对“定义于不同的编译单元内的non-local static对象“的初始化相对次序并无明确定义，使用Singleton模式解决这个问题。

# 若不想使用编译器自动生成的函数，就该明确拒绝

+ 为驳回编译器自动提供的技能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法（无成员且拷贝赋值函数和拷贝构造函数声明为private）。

# 为多态基类声明virtual析构函数

+ 当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结构未有定义——实际执行时通常发生的是对象的derived成员没被销毁。
+ 有时候希望拥有抽象class，但手上没有任何pure virtual函数。解法是声明一个pure virtual析构函数同时提供一份定义（避免derived class的析构函数报错）。
+ Class的设计目的如果不是作为base class使用，就不该声明virtual析构函数。

## 纯虚函数和虚函数的区别

定义一个函数为虚函数，不代表函数为不被实现的函数。

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

定义一个函数为纯虚函数，才代表函数没有被实现。

定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

# 别让异常逃离析构函数

+ 析构函数绝对不要吐出异常（可能导致未定义的行为）。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们或结束程序。
+ 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行操作（给客户一个处理错误的机会）。

# 绝不在构造和析构过程中调用virtual函数

+ 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。

# 令operator=返回一个reference to *this

+ 为了实现连锁赋值，令赋值操作符返回一个reference to *this。

# 在operator=中处理“自我赋值”

+ copy-and-swap。

# 复制对象时勿忘其每一个成分

+ Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。
+ 不要尝试以某个copying函数实现另一个copying函数。应该将共同技能放进第三个函数中，并由两个copying函数共同调用。

# 以对象管理资源

+ 把资源放进对象内，我们便可倚赖C++的“析构函数自动调用机制”确保资源被释放。

+ 获得资源后立刻放进管理对象内，“资源取得时机便是初始化时机”。
+ 为了防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。

# 在资源管理类中小心copying行为

+ 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为（常见的是：抑制copying、施行引用计数法）。

# 在资源管理类中提供对原始资源的访问

+ 一般而言显式转换比较安全，但隐式转换对客户比较方便。

# 成对使用new和delete时要采用相同形式

+ 在new表达式中使用[]，必须在相应的delete表达式中也使用[]。

# 以独立语句将newed对象置入智能指针

+ 编译器对“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度）。
+ 如果不这样做。一旦异常被抛出，可能导致难以察觉的资源泄露。

# 让接口容易被正确使用，不易被误用

+ 明智而审慎地导入新类型对预防“接口被误用”有神奇疗效。
+ 任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向。
+ 较佳接口的设计原则是先发制人。
+ “阻止误用”的办法包括建立新类型、限制新类型上的操作，束缚对象值，以及消除客户的资源管理责任。
+ shared_ptr支持定制型删除器。这可防范DDL问题，可被用来自动解除互斥锁。

# 设计class犹如设计type

+ 带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研讨class的设计。

# 宁以pass-by-reference-to-const替换pass-by-value

+ 这种传递方式的效率高得多：没有任何构造函数和析构函数被调用，因为没有任何新对象被创建。
+ 解决切割问题（引用和指针都能触发多态）。
+ reference往往以指针实现出来，如果有个对象属于内置类型，pass by value往往比pass-by-reference-to-const更高效。

# 必须返回对象时，别妄想返回其reference

+ 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。

# 将成员变量声明为private

+ 如果我们有一个public成员变量，而我们最终取消了它，所有使用它的客户代码都会被破坏。
+ 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，**并提供class作者以充分的实现弹性**（解耦合）。

# 宁以non-member、non-friend替换member函数

+ 越多东西被封装，就越少人可以看到它，我们就有越大的弹性去改变它。这就是我们推崇封装的原因：**它使我们能够改变事物而只影响有限客户**。
+ 将所有便利函数放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组便利函数。只需要在命名空间内建立一个头文件，内含那些函数的声明即可，而class定义式对客户而言是不能扩展的。
+ 这样做可以增加封装性、包裹弹性和机能扩充性。

# 若所有参数皆需类型转换，请为此采用non-member函数

# 考虑写出一个不抛出异常的swap函数

+ 所有STL容器也都提供有public swap成员函数和std::swap特化版本（用以调用前者）。





