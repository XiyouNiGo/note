# 设计模式

+ “每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”。

+ 软件设计的金科玉律：复用。
+ 面向对象设计最大的优势在于：抵御变化。
+ 设计模式的假设是必须有稳定点（全都是稳定点的话，设计模式也失去意义）。
+ 设计模式最大的作用是在变化和稳定中寻找隔离点，分离他们，从而管理变化。

# 面向对象设计原则

## 依赖倒置原则（DIP）

+ 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。
+ 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。
+ 依赖指的是编译时期的依赖，A依赖B -> B存在时A编译通过。

## 开放封闭原则（OCP）
+ 对扩展开放，对更改封闭。
+ 类模块应该是可扩展的，但是不可修改。

## 单一职责原则（SRP）

+ 一个类应该仅有一个引起它变化的原因。

+ 变化的方向隐含着类的责任。

## Liskov 替换原则（LSP）

+ 子类必须能够替换它们的基类(IS-A)。

+ 继承表达类型抽象。

## 接口隔离原则（ISP）

+ 不应该强迫客户程序依赖它们不用的方法。

+ 接口应该小而完备。

## 优先使用对象组合，而不是类继承

+ 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”。
+ 继承在某种程度上破坏了封装性，子类父类耦合度高。
+ 而对象组合则只要求被组合的对象具有良好定义的接口，耦合
  度低。

## 封装变化点

+ 使用封装来创建对象之间的分界层，让设计者可以在分界层的
  一侧进行修改，而不会对另一侧产生不良的影响，从而实现层
  次间的松耦合。

## 针对接口编程，而不是针对实现编程

+ 不将变量类型声明为某个特定的具体类，而是声明为某个接口。

+ 客户程序无需获知对象的具体类型，只需要知道对象所具有的
  接口。

+ 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”
  的类型设计方案。

# 重构关键技法
+ 静态 -> 动态
+ 早绑定 -> 晚绑定
+ 继承 -> 组合
+ 编译时依赖 -> 运行时依赖
+ 紧耦合 -> 松耦合

# Template Method

+ 定义：定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟(变化)到子类中。

+ Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的
  某些特定步骤。

+ 在具体实现方面，被Template Method调用的虚方法可以具有实
  现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将
  它们设置为protected方法。

# Strategy

+ 定义：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户序(稳定)而变化（扩展，子类化）。
+ Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。
+ 含有许多条件判断语句的代码通常都需要Strategy模式。
+ 有时候支持不使用的算法也是一个性能负担（if-else）。

# Observer

+ 定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
+ 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
+ 观察者自己决定是否需要订阅通知，目标对象对此一无所知。

# Decorator

+ 定义：动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消
  除重复代码 & 减少子类个数）。

+ Decorator类在接口上表现为is-a Component的继承关系，即  Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用 另外一个Component类。
+ Decorator模式的目的并非解决“多子类衍生的多继承”问题，  Decorator模式应用的要点在于解决“主体类在多个方向上的**扩展** 功能”——是为“装饰”的含义。

# Bridge

+ 定义：将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。
+ Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。