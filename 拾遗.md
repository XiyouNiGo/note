# 高性能服务器开发 技术专栏

+ 如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口。

+ 收发数据的正确姿势：
  + 对于 epoll LT 模式注册监听一次可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，不用再次注册可写事件；如果是  epoll 的 ET  模式，注册监听可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，需要再次注册可写事件以便让可写事件下次再次触发（给予再次发数据的机会）。当然，这只是理论上的情况，实际开发中，如果一段数据反复发送都不能完全发送完（例如对端先不收，后面每隔很长时间再收一个字节），我们可以设置一个最大发送次数或最大发送总时间，超过这些限定，我们可以认为对端出了问题，应该立即清空发送缓冲区并关闭连接。
  + 在 select、poll 和 epoll 的 LT 模式下，可以直接设置检测 fd 的可读事件；
  + 在 select、poll 和 epoll 的 LT 模式下不要直接设置检测 fd 的可写事件，应该先尝试发送数据，因为 TCP 窗口太小发不出去再设置检测 fd 的可写事件，一旦数据发出去应立即取消对可写事件的检测。
  + 在 epoll 的 ET 模式下，需要发送数据时，每次都要设置检测可写事件。
+ 非阻塞connect：
  + 创建socket，并将 socket 设置成非阻塞模式。
  2. 调用 connect 函数，此时无论 connect 函数是否连接成功会立即返回；如果返回-1且错误码是EINPROGRESS并不表示连接出错。
  3. 接着调用 select 函数，再调用getsockopt判断该socket状态，如果没有错误说明连接成功，反之则认为连接失败。
+ send 和 recv 函数在阻塞和非阻塞模式下的行为：
  3. send 函数本质上并不是往网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区。
  3. recv 函数本质上也并不是从网络上收取数据，而只是将内核缓冲区中的数据拷贝到应用程序的缓冲区中。
3. 由于 keepalive 选项需要为每个连接中的 socket 开启，这不一定是必须的，可能会产生大量无意义的带宽浪费，且 keepalive 选项不能与应用层很好地交互，因此一般实际的服务开发中，还是建议在应用层设计自己的心跳包机制。

