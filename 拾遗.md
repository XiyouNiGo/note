# 高性能服务器开发 技术专栏

+ 如果将 bind 函数中的端口号设置成0，那么操作系统会随机给程序分配一个可用的侦听端口。

+ 收发数据的正确姿势：
  + 对于 epoll LT 模式注册监听一次可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，不用再次注册可写事件；如果是  epoll 的 ET  模式，注册监听可写事件后，可写事件触发后，尝试发送数据，如果数据此时还不能全部发送完，需要再次注册可写事件以便让可写事件下次再次触发（给予再次发数据的机会）。当然，这只是理论上的情况，实际开发中，如果一段数据反复发送都不能完全发送完（例如对端先不收，后面每隔很长时间再收一个字节），我们可以设置一个最大发送次数或最大发送总时间，超过这些限定，我们可以认为对端出了问题，应该立即清空发送缓冲区并关闭连接。
  + 在 select、poll 和 epoll 的 LT 模式下，可以直接设置检测 fd 的可读事件；
  + 在 select、poll 和 epoll 的 LT 模式下不要直接设置检测 fd 的可写事件，应该先尝试发送数据，因为 TCP 窗口太小发不出去再设置检测 fd 的可写事件，一旦数据发出去应立即取消对可写事件的检测。
  + 在 epoll 的 ET 模式下，需要发送数据时，每次都要设置检测可写事件。
+ 非阻塞connect：
  + 创建socket，并将 socket 设置成非阻塞模式。
  2. 调用 connect 函数，此时无论 connect 函数是否连接成功会立即返回；如果返回-1且错误码是EINPROGRESS并不表示连接出错。
  3. 接着调用 select 函数，再调用getsockopt判断该socket状态，如果没有错误说明连接成功，反之则认为连接失败。
+ send 和 recv 函数在阻塞和非阻塞模式下的行为：
  3. send 函数本质上并不是往网络上发送数据，而是将应用层发送缓冲区的数据拷贝到内核缓冲区。
  3. recv 函数本质上也并不是从网络上收取数据，而只是将内核缓冲区中的数据拷贝到应用程序的缓冲区中。
3. 由于 keepalive 选项需要为每个连接中的 socket 开启，这不一定是必须的，可能会产生大量无意义的带宽浪费，且 keepalive 选项不能与应用层很好地交互，因此一般实际的服务开发中，还是建议在应用层设计自己的心跳包机制。

# kmalloc()、kzalloc()、vmalloc()

+ kmalloc()、kzalloc()、vmalloc() 的共同特点是：

  + 用于申请内核空间的内存；

  + 内存以字节为单位进行分配；

  + 所分配的内存虚拟地址上连续；

+ kmalloc()、kzalloc()、vmalloc() 的区别是：
  + kzalloc 是强制清零的 kmalloc 操作；（以下描述不区分 kmalloc 和 kzalloc）

  + kmalloc 分配的内存大小有限制（128KB），而 vmalloc 没有限制；

  + kmalloc 可以保证分配的内存物理地址是连续的，但是 vmalloc 不能保证；

  + kmalloc 分配内存的过程可以是原子过程（使用 GFP_ATOMIC），而 vmalloc 分配内存时则可能产生阻塞；

  + kmalloc 分配内存的开销小，因此 kmalloc 比 vmalloc 要快；

+ 一般情况下，内存只有在要被 DMA 访问的时候才需要物理上连续，但为了性能上的考虑，内核中一般使用 kmalloc()，而只有在需要获得大块内存时才使用  vmalloc()。例如，当模块被动态加载到内核当中时，就把模块装载到由 vmalloc() 分配的内存上。
