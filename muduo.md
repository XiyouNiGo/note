# 第4章 C++多线程系统编程精要

## Linux上的线程标识

+ pthread_t：进程内唯一的，不同进程内可能相同。pthread的值很容易重复。

+ pid_t：全局唯一，不同进程内也不相同。而且是采用递增轮回法分配，短时间内启动多个线程也会具有不同的线程id。
+ 建议使用gettid系统调用的返回值作为线程id。
+ Current::tid使用__thread变量来缓存gettid的返回值。避免子进程fork后看到缓存，用pthread_atfork()注册一个回调来清空缓存。

## 线程的创建与销毁的守则

+ 程序不应该在未提前告知的情况下创建自己的“背景线程”。这样程序可以统筹线程的数目和用途，避免低优先级的任务独占某个线程。
+ 尽量用相同的方式创建线程。容易做一些统一的簿记工作。
+ 在进入main()函数之前不应该启动线程。避免影响全局对象的安全构造（C++保证在进入main()之前完成全局对象的构造）。
+ 程序中线程的创建最好在初始化阶段全部完成。
+ 任何从外部强行终止线程的做法和想法都是错的。

### pthread_cancel与C++

+ 线程不是执行到此函数就立刻终止，而是该函数会抛出异常。这样可以有机会执行stack unwind。

### exit在C++中不是线程安全的

+ exit会析构全局对象和static对象，不析构局部对象（不存在栈空间回收的问题）。因此可能造成死锁，析构函数的竟态条件。
+ 可以考虑用_exit系统调用。它不会试图析构全局对象，但是也不会执行其他任何清理工作。

### 善用\_\_thread与关键字

+ \_\_thread是GCC内置的**线程局部存储设施**，比pthread\_key\_t快很多，存取效率可与全局变量相比。
+ \_\_thread无法自动调用构造函数和析构函数，只能用于修饰全局变量和静态变量，初始化只能用编译期常量。

## 多线程与IO

+ 操作文件描述符的系统调用本身是线程安全的。
+ socket读写的特点是不保证完整性。
+ 多个线程**分别**read或write**同一个磁盘**上的多个文件也不见得能提速。因为每块磁盘都有一个操作队列，多个线程的读写请求到了内核是排队执行的。只有在内核缓存了大部分数据的情况下，多线程读这些热数据才可能比单线程快。
+ **每个文件描述符只由一个线程操作**，从而轻松解决消息收发的顺序性问题，也避免了关闭文件描述符的各种race condition。
+ 对于磁盘文件，在必要的时候多个线程可以同时调用pread/pwrite（相当于先调用lseek）来读写同一个文件。
+ 对于UDP，由于协议本身保证消息的原子性，可以多个线程同时读写同一个UDP文件描述符。

## 用RAII包装文件描述符

+ POSIX标准要求每次新打开文件的时候必须使用当前最小可用的文件描述符号码，这种分配方式可能导致**串话**。因此不应该stdout或stderr，正确的做法是把stdout或stderr重定向到磁盘文件。
+ 用全局表来避免串话通常意味着每次读写都要对全局表加锁。
+ RAII：用Socket对象包装文件描述符，所有对此文件描述符的读写都通过此对象进行，在对象的析构函数里关闭文件描述符。
+ 为了防止访问失效的对象或者发生网络串话，muduo使用shared_ptr来管理TcpConnection的生命期。

## RAII与fork()

+ 用RAII手法管理子进程未继承的资源时（定时器、内存锁、文件锁等等），fork出来的子进程不一定正常工作。

## 多线程与fork()

+ Linux的fork()只克隆当前线程的thread of control，不克隆其他线程。fork()后，其他线程可能正好位于临界区之内，持有了某把锁，而它突然死亡，再也没有机会去解锁了。

  因此子进程不能调用：malloc、任何可能分配和释放内存的函数、printf系列函数、任何Pthreads函数。

+ 唯一安全的做法是在fork()之后立即调用exec()执行另一个程序。

## 多线程与signal

+ 在signal handler中只能调用可重入函数，不是每个线程安全的函数都是可重入的。
+ 在signal handler中不能调用任何Pthreads函数。
+ 如果signal handler中需要修改全局数据，那么被修改的变量必须是sig_atomic_t类型的。因为编译器有可能假定这个变量不会被他处修改，从而优化了内存访问。
+ 使用signal的第一原则是**不要使用signal**。
+ 也不要使用基于signal实现的定时函数。
+ 不主动处理各种异常信号。
+ 在没有别的替代方法的情况下，使用signalfd统一事件源。

# 第5章 高效的多线程日志

## 功能需求

+ 调整日志的输出级别不需要重新编译，也不需要重启进程。

+ 应该避免往网络文件系统（例如NFS）上写日志，这等于掩耳盗铃。

+ 以本地文件为日志的destination，日志文件的滚动是必需的。

+ 万一程序崩溃，那么最后若干条日志往往就丢失了。

  muduo日志库用两个办法来应对这一点：其一是定期将缓冲区内的日志消息flush到硬盘；其二是每条内存中的日志消息都带有cookie，其值为某个函数的地址，这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息。

## 多线程异步日志

+ 一个多线程程序的每个进程最好只写一个日志文件。
+ “异步日志”：用一个背景线程负责收集日志消息，并写入日志文件，其他业务线程只管往这个“日志线程”发送日志消息。（防止阻塞）
+ 双缓冲技术：在新建日志消息的时候不必等待磁盘文件操作，也避免每条新消息都触发后端日志线程（相当于于批处理）。

